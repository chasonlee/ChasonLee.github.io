<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观星客</title>
  
  <subtitle>...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chason.pro/"/>
  <updated>2021-05-20T17:26:56.682Z</updated>
  <id>http://chason.pro/</id>
  
  <author>
    <name>Chason Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker超详细教程</title>
    <link href="http://chason.pro/docker-tutorial/"/>
    <id>http://chason.pro/docker-tutorial/</id>
    <published>2019-05-15T16:00:00.000Z</published>
    <updated>2021-05-20T17:26:56.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2><p>Docker的诞生，让应用的部署变得前所未有的高效，它能将应用及其依赖项打包成容器分发部署，从而保证了应用运行环境的一致性。Docker容器其实是一种比虚拟机更轻量的技术，容器中的进程直接运行在宿主机的内核，其启动速度十分快，基本可以做到秒级启动，并不像虚拟机那样对硬件进行模拟，并在之上运行一整套操作系统，所以容器相比虚拟机更为轻便。</p><a id="more"></a><hr><h2 id="理解docker"><a class="header-anchor" href="#理解docker">¶</a>理解Docker</h2><p>Docker有三个基本概念：仓库（Repository），镜像（Image）和容器（Container）。</p><ul><li><strong>仓库（Repository）</strong> 是一个集中存放镜像的空间。我们写的代码可以上传到<a href="https://github.com/" target="_blank" rel="noopener">Github</a>仓库中，类似的，Docker的镜像就能上传到<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>仓库，以便镜像的分发部署。Docker Hub是官方的公开服务，每个账号可以建立一个免费的私有仓库。</li><li><strong>镜像（Image）</strong> 是一个特殊的文件系统，其中存储了应用和环境的所有数据，镜像在构建之后是静态的，不可改变的。</li><li><strong>容器（Container）</strong> 是镜像的运行实体，类似于面向对象编程中的<strong>类</strong>与<strong>实例</strong>，一个静态的镜像可以产生多个独立动态运行的容器。我们实际使用Docker就是在容器中运行自己的应用，每个容器都有自己独立的运行空间，与宿主系统环境隔绝。</li></ul><hr><h2 id="快速上手docker"><a class="header-anchor" href="#快速上手docker">¶</a>快速上手Docker</h2><p>为了让读者能快速上手Docker，下面以一个实际应用进行说明，让我们从易到难，先假设目前已经构建好一个镜像，后面我们会具体讲如何构建这个镜像。读者可以跟随本文实际操作，学习效果会更佳。</p><h3 id="一-安装docker"><a class="header-anchor" href="#一-安装docker">¶</a>一、安装Docker</h3><p>本文以Ubuntu系统安装Docker CE版本为例，更详细的其他版本安装步骤可以参考<a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker官网文档</a></p><ol><li>卸载旧版本</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><ol start="2"><li>安装依赖包</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><ol start="3"><li>添加GPG key，并设置<code>stable</code>版本的仓库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>apt-get安装</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><ol start="5"><li>验证安装结果</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --rm hello-world</span><br></pre></td></tr></table></figure><p><code>--rm</code>参数代表我们运行后随即删除这个容器，因为我们只需要这个容器输出一段信息而已。</p><p>执行后会输出类似这样的信息，说明已经安装成功：</p><blockquote><p>Hello from Docker!<br>This message shows that your installation appears to be working correctly.</p><p>To generate this message, Docker took the following steps:</p><ol><li>The Docker client contacted the Docker daemon.</li><li>The Docker daemon pulled the “hello-world” image from the Docker Hub.<br>(amd64)</li><li>The Docker daemon created a new container from that image which runs the<br>executable that produces the output you are currently reading.</li><li>The Docker daemon streamed that output to the Docker client, which sent it<br>to your terminal.</li></ol><p>To try something more ambitious, you can run an Ubuntu container with:<br>$ docker run -it ubuntu bash</p><p>Share images, automate workflows, and more with a free Docker ID:<br><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><p>For more examples and ideas, visit:<br><a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener">https://docs.docker.com/get-started/</a></p></blockquote><ol start="6"><li>免sudo运行<br>每次运行docker都要加一个sudo挺麻烦，我们将当前账号加入Docker组里面即可免sudo运行Docker：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br><span class="line">sudo gpasswd -a $&#123;USER&#125; docker</span><br><span class="line">sudo service docker restart</span><br><span class="line">newgrp - docker</span><br></pre></td></tr></table></figure><h3 id="二-镜像操作"><a class="header-anchor" href="#二-镜像操作">¶</a>二、镜像操作</h3><h4 id="1-获取docker镜像"><a class="header-anchor" href="#1-获取docker镜像">¶</a>1、获取Docker镜像</h4><p>笔者在Ubuntu 16.04镜像的基础上，制作了一个很简单的Docker镜像，里面有一个<code>my_clock.py</code>Python文件，执行后就会间隔一秒钟输出一次当前系统时间。此镜像我已经上传到自己的<a href="https://cloud.docker.com/repository/docker/chasonlee/ubuntu_demo" target="_blank" rel="noopener">Docker Hub公共仓库</a>中，任何人都可以随时下载，执行以下命令即可将此镜像下载到本地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull chasonlee/ubuntu_demo:latest</span><br></pre></td></tr></table></figure><p>其中<code>chasonlee/ubuntu_demo</code>是镜像名字，<code>latest</code>是镜像的标签Tag，不同的Tag代表不同的版本，执行后会显示如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">latest: Pulling from chasonlee/ubuntu_demo</span><br><span class="line">9ff7e2e5f967: Pull complete</span><br><span class="line">59856638ac9f: Pull complete</span><br><span class="line">6f317d6d954b: Pull complete</span><br><span class="line">a9dde5e2a643: Pull complete</span><br><span class="line">583e635329f1: Pull complete</span><br><span class="line">d74dae086c4f: Pull complete</span><br><span class="line">Digest: sha256:f4396916a5cbb3ece8e5eb74a860d956b8957965675d5dde707ed4f316407b8c</span><br><span class="line">Status: Downloaded newer image for chasonlee/ubuntu_demo:latest</span><br></pre></td></tr></table></figure><p>从信息中我们可以看出，镜像的下载是一层一层分开的，镜像是分层存储，<code>9ff7e2e5f967</code>是其中一层。Docker有一个优点，不同镜像之间如果基于某些相同的镜像进行定制化修改，就可以共享部分相同的层，从而节省空间的占用。</p><h4 id="2-查看本地镜像"><a class="header-anchor" href="#2-查看本地镜像">¶</a>2、查看本地镜像</h4><p>执行以下命令可以查看当前所有本地镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>执行后就能看到我们刚刚pull回来的镜像和一个之前的hello-world镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                TAG                     IMAGE ID            CREATED             SIZE</span><br><span class="line">chasonlee/ubuntu_demolatest                  59693b89568e        2 minutes ago         158MB</span><br><span class="line">hello-world               latest                  fce289e99eb9        4 months ago        1.84kB</span><br></pre></td></tr></table></figure><p><em>可能读者会疑惑为什么有hello-world镜像，因为当我们执行<code>docker run --rm hello-world</code>的时候，在本地找不到hello-world镜像，就会自动到Docker Hub上找到相应镜像下载回来，再根据此镜像来新建并启动容器。</em></p><p>另外，我们也可以查看<strong>中间层镜像</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -a</span><br></pre></td></tr></table></figure><p>如果不同镜像之间有复用的中间层，这里就会看见一些没有镜像名和标签的镜像，很多镜像依赖这些中间层，所以中间层镜像是<strong>不能随意删除</strong>的。</p><h4 id="3-删除镜像"><a class="header-anchor" href="#3-删除镜像">¶</a>3、删除镜像</h4><p>当我们想删除一些不需要的镜像时，比如<code>hello-world</code>镜像，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi hello-world</span><br></pre></td></tr></table></figure><p>如果此时有基于此镜像的容器，则需要先删除相应的容器才能删除此镜像，如果想强制删除镜像，加上<code>-f</code>参数即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f &lt;image name&gt;</span><br></pre></td></tr></table></figure><p>在使用<code>docker images</code>查看本地镜像时（不加<code>-a</code>参数时），我们也可能会发现一些没有镜像名和标签的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                TAG                     IMAGE ID            CREATED             SIZE</span><br><span class="line">chasonlee/ubuntu_demolatest                  59693b89568e        2 minutes ago         158MB</span><br><span class="line">hello-world               latest                  fce289e99eb9        4 months ago        1.84kB</span><br><span class="line">&lt;none&gt;&lt;none&gt;                  3517732c5437        7 weeks ago2.74GB</span><br></pre></td></tr></table></figure><p>不同于上面提到的中间层镜像，我们称这种镜像为<strong>虚悬镜像（dangling image）</strong>，有几种情况会产生虚悬镜像，比如上述强制删除一个已经运行容器的镜像，或者使用<code>docker pull</code>命令更新镜像时，镜像的名称和标签会转移到新镜像中，旧的镜像就会变成虚悬镜像，另外，在使用<code>docker build</code>构建镜像的时候，如果构建失败也会产生虚悬镜像。一般来说虚悬镜像已经没有实际用处，可以随意删除，一条命令就能清除所有虚悬镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure><h4 id="4-导出镜像"><a class="header-anchor" href="#4-导出镜像">¶</a>4、导出镜像</h4><p>上文中我们用<code>docker pull</code>命令将镜像从Docker Hub下载到本地，如果目标环境不能访问外网时无法下载，我们就可以直接导出镜像文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o ubuntu_demo.tar chasonlee/ubuntu_demo</span><br></pre></td></tr></table></figure><ul><li><code>-o</code>参数后面接着输出文件名。</li><li><code>chasonlee/ubuntu_demo</code>是需要导出的镜像名。</li></ul><p>注意：这里只是导出一个静态的镜像，根据当前镜像启动的容器环境并不能直接导出，如果需要迁移当前容器的环境，还需要先使用<code>commit</code>命令自行制作一个镜像再导出，详情可跳转到<a href="http://chason.me/docker-tutorial/#%E4%B8%80-%E7%90%86%E8%A7%A3commit" target="_blank" rel="noopener">理解commit</a>章节阅读。</p><p>假如镜像文件很大，可以直接压缩导出镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save chasonlee/ubuntu_demo:latest | gzip &gt; ubuntu_demo.tar.gz</span><br></pre></td></tr></table></figure><h4 id="5-导入镜像"><a class="header-anchor" href="#5-导入镜像">¶</a><em>5、导入镜像</em></h4><p>然后拷贝此镜像文件到目标环境中，并导入镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i ubuntu_demo.tar</span><br></pre></td></tr></table></figure><p>或者直接导入压缩后的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip -c ubuntu_demo.tar.gz | docker load</span><br></pre></td></tr></table></figure><p>导入后可以即可通过<code>docker images</code>查看镜像。</p><h4 id="6-修改镜像名称及标签"><a class="header-anchor" href="#6-修改镜像名称及标签">¶</a>6、修改镜像名称及标签</h4><p>如果我们想把镜像名称改为<code>ubuntu_chason:1.0</code>，则执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag chasonlee/ubuntu_demo:latest ubuntu_chason:1.0</span><br></pre></td></tr></table></figure><h3 id="三-容器操作"><a class="header-anchor" href="#三-容器操作">¶</a>三、容器操作</h3><h4 id="1-新建并启动容器"><a class="header-anchor" href="#1-新建并启动容器">¶</a>1、新建并启动容器</h4><p>前面我们有讲过，镜像是静态的，容器才是实际运行的实体，Docker可以基于某个镜像新建容器。可以这么理解，用一个镜像来初始化新建的容器。容器运行之后的所有变化都不会反过来影响镜像，容器在运行终止后，里面新产生的数据将会随之丢弃。</p><p>为了方便，我们通常会新建容器并让其后台持续运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name my_ubuntu chasonlee/ubuntu_demo:latest</span><br></pre></td></tr></table></figure><ul><li><code>-dit</code>有三个参数，其顺序没有影响，<code>-t</code>能让Docker分配一个伪终端，并绑定到容器的输入上，<code>-i</code>能让容器的标准输入保持打开状态，<code>-d</code>则可以让容器在后台保持运行。</li><li><code>--name my_ubuntu</code>可以为容器命名，方便自己管理。</li><li><code>chasonlee/ubuntu_chason:latest</code>是初始化容器的镜像名加标签Tag。</li></ul><p>执行后就会打印一行此容器的ID，说明容器已经成功在后台运行。</p><p>另外，我们也可以在让容器一次性运行一条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm chasonlee/ubuntu_demo:latest echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure><ul><li><code>--rm</code>我们之前解释过，是为了容器停止后直接删除，避免留下一个已经停止的容器。</li></ul><p>这条命令看起来和我们在本地直接运行<code>echo &quot;hello world&quot;</code>并没有什么区别，我们只是在容器中执行了echo指令，输出结果，容器就停止了。</p><p>或者我们也可以直接运行容器的bash终端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm chasonlee/ubuntu_demo:latest bash</span><br></pre></td></tr></table></figure><p>执行本命令就会看到容器的伪终端，此时我们就继续在容器中执行命令，要注意的是，当我们执行<code>exit</code>退出容器时，容器就会停止，<code>--rm</code>参数会在容器停止后直接删除容器。</p><h4 id="2-查看容器"><a class="header-anchor" href="#2-查看容器">¶</a>2、查看容器</h4><p>执行以下命令可以查看所有容器及其状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>执行后会输出以下类似信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER IDIMAGECOMMANDCREATEDSTATUSPORTSNAMES</span><br><span class="line">d346805da373chasonlee/ubuntu_demo:latest&quot;/bin/bash&quot;2 minutes agoUp 2 minutesmy_ubuntu</span><br></pre></td></tr></table></figure><p>可见my_ubuntu就是我们新建好的容器，<code>Up 2 minutes</code>代表容器正在后台运行，已经运行2分钟。</p><h4 id="3-进入容器"><a class="header-anchor" href="#3-进入容器">¶</a>3、进入容器</h4><p>执行以下命令即可进入容器中的bash：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it my_ubuntu bash</span><br></pre></td></tr></table></figure><ul><li><code>-it</code>和前面一样代表打开标准输入和分配伪终端。</li><li><code>my_ubuntu</code>是要进入容器的名字，我们如果换成容器ID<code>d346805da373</code>也是一样的，但使用名字肯定更方便直观。</li><li>最后的参数代表我们需要容器执行的命令，我们需要交互式的Shell，所以这里输入<code>bash</code>，如果我们只需要执行容器里面的一个命令，可以将<code>bash</code>替换成想执行的命令即可。</li></ul><p>执行后即可进入容器中：</p><img src="/docker-tutorial/enter_docker.jpg" title="进入容器后的界面"><p><em>或者执行<code>docker attach my_ubuntu</code>也可以进入容器，但不推荐使用，原因后面会讲。</em></p><p>容器里面是独立的系统环境，我已经配置默认采用Python3，并在workspace中存放my_clock.py文件，执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python my_clock.py</span><br></pre></td></tr></table></figure><p>程序会每隔一秒在界面中打印系统时间：</p><img src="/docker-tutorial/run_clock.jpg" title="在容器中执行Python程序"><p>我还在容器中安装了<code>htop</code>工具，用于查看CPU、内存使用情况，执行<code>htop</code>即可查看：</p><img src="/docker-tutorial/htop.jpg" title="在容器中运行预装的htop工具"><p>简单的程序可以如上直接在容器中运行，虽然我们在运行容器时加入了<code>-d</code>参数能保持程序一直运行，但我们无法在重新进入容器时看到程序以前输出的结果。如果需要长时间保持程序的运行，笔者还是推荐在容器中使用tmux，<a href="http://chason.me/tmux-tutorial/" target="_blank" rel="noopener">tmux教程在这里</a>。</p><h4 id="4-退出容器"><a class="header-anchor" href="#4-退出容器">¶</a>4、退出容器</h4><p>退出容器很简单，直接执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><p>即可回到系统bash中，现在再用<code>docker ps -a</code>查看容器状态，依旧是<code>Up</code>运行状态:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER IDIMAGECOMMANDCREATEDSTATUSPORTSNAMES</span><br><span class="line">d346805da37359693b89568e&quot;/bin/bash&quot;10 minutes agoUp 10 minutesmy_ubuntu</span><br></pre></td></tr></table></figure><p>这是因为我们进入容器时使用的是<code>docker exec</code>命令，如果我们使用的是<code>docker attach</code>命令，退出容器后，容器将会停止运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER IDIMAGECOMMANDCREATEDSTATUS                     PORTSNAMES</span><br><span class="line">d346805da37359693b89568e&quot;/bin/bash&quot;10 minutes agoExited (1) 4 seconds agomy_ubuntu</span><br></pre></td></tr></table></figure><h4 id="5-启动停止容器"><a class="header-anchor" href="#5-启动停止容器">¶</a>5、启动停止容器</h4><p>容器停止时，可以启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start my_ubuntu</span><br></pre></td></tr></table></figure><p>容器正在运行时，也可以停止容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop my_ubuntu</span><br></pre></td></tr></table></figure><h4 id="6-删除容器"><a class="header-anchor" href="#6-删除容器">¶</a>6、删除容器</h4><p>当容器已经停止时，可以直接删除容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm my_ubuntu</span><br></pre></td></tr></table></figure><p>当容器还在运行，可以强制删除容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f my_ubuntu</span><br></pre></td></tr></table></figure><p>如果当前有很多已经停止的容器，一个命令即可清空所有已停止容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure><h4 id="7-导出容器快照-不推荐"><a class="header-anchor" href="#7-导出容器快照-不推荐">¶</a><s>7、导出容器快照（不推荐）</s></h4><p><s>类似镜像的导出，我们同样可以导出容器快照：</s></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export my_ubuntu &gt; my_ubuntu.tar</span><br></pre></td></tr></table></figure><p><s>容器快照会丢弃所有的历史记录和元数据信息，仅保存容器当时的快照状态。</s></p><h4 id="8-导入容器快照-不推荐"><a class="header-anchor" href="#8-导入容器快照-不推荐">¶</a><s>8、导入容器快照（不推荐）</s></h4><p><s>有了容器快照文件，即可将容器快照导入新的镜像中：</s></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import my_ubuntu.tar my_ubuntu:1.0</span><br></pre></td></tr></table></figure><ul><li><s><code>my_ubuntu.tar</code>是容器快照。</s></li><li><s><code>my_ubuntu:1.0</code>是新镜像名和标签TAG，若不写TAG，默认为<code>latest</code>。</s><br><s>注意，是导入到镜像中，而不是直接新建一个容器。</s></li></ul><h4 id="9-挂载目录"><a class="header-anchor" href="#9-挂载目录">¶</a>9、挂载目录</h4><p>当我们需要访问宿主机的数据时，就需要把宿主机目录挂载到容器中，在新建容器时使用<code>docker run -v</code>参数即可挂载目录，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name my_ubuntu -v /hdd:/workspace/hdd chasonlee/ubuntu_demo:latest</span><br></pre></td></tr></table></figure><ul><li><code>-v</code>代表挂载目录，宿主机目录和容器目录用<code>:</code>分开，如果需要挂载多个目录，继续多写几个<code>-v</code>及其对应目录即可。</li><li><code>/hdd</code>是宿主机目录，必须是绝对路径。</li><li><code>/workspace/hdd</code>是容器里面映射的目录，必须是绝对路径，如果目录不存在会自动创建。</li></ul><blockquote><p>至此阶段，相信读者已经掌握了docker的基本使用方法，接下来将会介绍如何制作自定义的镜像。</p></blockquote><hr><h2 id="镜像制作"><a class="header-anchor" href="#镜像制作">¶</a>镜像制作</h2><p>在<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>中，除了笔者举例的镜像，我们还可以搜索到其他很多高质量的镜像，例如<a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">Ubuntu官方镜像</a>、<a href="https://hub.docker.com/r/tensorflow/tensorflow" target="_blank" rel="noopener">TensorFlow官方镜像</a>等等。有了这些镜像，我们就没有必要重复造轮子，若这些镜像无法完全满足需求，我们只需要基于这些镜像做一些定制化的修改即可。</p><h3 id="一-理解commit"><a class="header-anchor" href="#一-理解commit">¶</a>一、理解commit</h3><p>镜像的制作，有一种最简单快速的方式是<code>docker commit</code>，只需在某个镜像基础上，启动容器，并在容器中安装自己需要的环境，即可将此容器commit到一个新的镜像中。</p><p>基本语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [可选项] 容器 [镜像[:标签]]</span><br></pre></td></tr></table></figure><ul><li><code>可选项</code>包括：<br>-a (–author string): 镜像制作者信息，如&quot;<a href="http://chason.me" target="_blank" rel="noopener">chason.me</a>&quot;<br>-c (–change list): 使用Dockerfile指令来创建镜像<br>-m (–message string): 提交时的说明信息<br>-p (–pause): 在commit时，将容器暂停，默认为True</li><li><code>容器</code>可以写容器名或容器ID</li><li><code>镜像[:标签]</code>代表你要新建的镜像和标签名</li></ul><p>假如我们已经在容器<code>my_ubuntu</code>中安装好一切需要的环境，退出容器后，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -a &quot;chason.me&quot; -m &quot;new environment&quot; my_ubuntu chason_env:latest</span><br></pre></td></tr></table></figure><p>即可创建一个名为<code>chason_env:latest</code>镜像，<a href="http://chason.me/docker-tutorial/#4-%E5%AF%BC%E5%87%BA%E9%95%9C%E5%83%8F" target="_blank" rel="noopener">导出此镜像</a>即可将环境迁移至其他机器使用。</p><p>需要提醒的是，<code>docker commit</code>虽然很方便，但并<strong>不推荐</strong>使用，因为在容器中的每一次操作我们都可能产生很多临时文件，造成镜像越来越臃肿，而且每次操作无法回溯，我们很难知道这个镜像到底执行过什么命令，导致镜像难以维护。</p><p>那是否存在一种方法，能让镜像的修改操作透明、同时又能解决臃肿问题呢？当然有，答案就是<strong>Dockerfile</strong>！</p><h3 id="二-学习dockerfile"><a class="header-anchor" href="#二-学习dockerfile">¶</a>二、学习Dockerfile</h3><p>Dockerfile是一个文本文件，包含了镜像构建的所有命令，通过修改Dockerfile中的命令，就能定制化自己想要的镜像。Dockerfile里面每一个指令都会构建一层镜像，层层叠加最终得到定制化镜像。</p><h4 id="1-基本指令"><a class="header-anchor" href="#1-基本指令">¶</a>1、基本指令</h4><p>让我们重新回到原来的例子，<code>chasonlee/ubuntu_demo</code>镜像是如何构建的呢？</p><p>首先我们在本地新建一个文件夹，专门存放Dockerfile和其他所需文件，并在里面新建<code>my_clock.py</code>程序以及<code>Dockerfile</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir my_docker</span><br><span class="line">cd my_docker</span><br><span class="line">vim my_clock.py</span><br></pre></td></tr></table></figure><p>在Python文件中输入持续打印当前时间的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># coding: utf-8</span><br><span class="line">import time</span><br><span class="line">while True:</span><br><span class="line">    print (time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()))</span><br><span class="line">    time.sleep(1)</span><br></pre></td></tr></table></figure><p>保存代码后，在同样的目录下新建Dockerfile文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><p>输入以下Dockerfile指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">ENV WORK_DIR=/workspace</span><br><span class="line">WORKDIR $&#123;WORK_DIR&#125;</span><br><span class="line">COPY . $&#123;WORK_DIR&#125;</span><br><span class="line">RUN apt update \</span><br><span class="line">&amp;&amp; apt install -y python3 \</span><br><span class="line">&amp;&amp; apt install -y htop \</span><br><span class="line">&amp;&amp; apt install -y tzdata \</span><br><span class="line">&amp;&amp; apt-get clean \</span><br><span class="line">&amp;&amp; apt-get autoclean \</span><br><span class="line">&amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* \</span><br><span class="line">&amp;&amp; ln -s /usr/bin/python3 /usr/bin/python \</span><br><span class="line">&amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><br><span class="line">&amp;&amp; echo &apos;Asia/Shanghai&apos; &gt;/etc/timezone \</span><br></pre></td></tr></table></figure><ul><li><code>FROM</code>指令代表基于哪个镜像进行修改，第一条指令必须是<code>FROM</code>指令，若我们不想基于任何镜像，可以写<code>FROM scratch</code>即可完全从零开始构建镜像。</li><li><code>ENV</code>指令可以创建环境变量，比如<code>WORK_DIR</code>工作目录环境变量，后面就能通过<code>${WORK_DIR}</code>调用环境变量的值。</li><li><code>COPY</code>指令可以将宿主机中的文件在构建镜像时复制到镜像存储中。</li><li><code>WORKDIR</code>指令可以指定工作目录，在刚进入容器时，系统会自动转到工作目录，默认的工作目录是根目录<code>/</code>。</li><li><code>RUN</code>指令就是用来执行命令的指令，由于一条指令就会创建一层镜像，而镜像层数是有限制的，一般是127层，当我们需要执行多条命令时，一般都用<code>&amp;&amp;</code>连接多条命令，从而节省镜像层数。</li></ul><p>现在我们逐条命令讲解以上Dockerfile的内容:</p><ol><li>首先是基于<code>ubuntu:16.04</code>镜像开始构建</li><li>设置环境变量WORK_DIR为<code>/workspace</code></li><li>设置工作目录为WORK_DIR</li><li>复制宿主机当前目录所有文件到镜像WORK_DIR目录中，包含<code>Dockerfile</code>和<code>my_clock.py</code></li><li>更新apt列表</li><li>安装Python3，<code>-y</code>代表默认同意安装，这样就不需要手动输入y确认安装。</li><li>安装htop工具</li><li>安装tzdata时间工具</li><li>清除临时软件包</li><li>清除临时软件包</li><li>清除临时文件</li><li>将python软连接到python3</li><li>将系统默认时区设置为亚洲上海</li><li>将系统默认时区设置为亚洲上海</li></ol><p>从Dockerfile可见，整个镜像的构建过程都是透明的、清晰的，为了避免镜像过于臃肿，需要时刻记得清除无用的数据，否则镜像的大小容易失去控制。</p><p>定制自己的镜像就是写一份Dockerfile，把想要的程序或工具的安装命令直接写入Dockerfile即可，比如想用tmux的读者，在Dockerfile里面插入<code>apt install -y tmux</code>即可。</p><h4 id="2-拓展指令"><a class="header-anchor" href="#2-拓展指令">¶</a>2、拓展指令</h4><h5 id="add指令"><a class="header-anchor" href="#add指令">¶</a>ADD指令</h5><p><code>ADD</code>指令和<code>COPY</code>类似，但包含更多功能，比如可以从一个网址下载文件到目标目录中（下载后文件默认权限是<code>600</code>），另外一个常用的功能是自动解压，支持gzip、bzip2和xz压缩格式，比如<code>ADD file.tar /</code>会将压缩包解压到目标路径中。</p><p>由于<code>ADD</code>指令语义不够清晰，除了需要自动解压的情况，我们一般都<strong>不推荐</strong>使用<code>ADD</code>指令。</p><h5 id="cmd指令"><a class="header-anchor" href="#cmd指令">¶</a>CMD指令</h5><p>运行格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></p><p><code>CMD</code>指令可以用来指定容器默认的运行命令，比如之前我们提到可以这样直接执行容器的bash指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm chasonlee/ubuntu_demo:latest bash</span><br></pre></td></tr></table></figure><p>其实后面的<code>bash</code>不写也行，因为<code>ubuntu:16.04</code>镜像中已经用CMD指令设置好默认命令为<code>bash</code>。</p><p>若我们在Dockerfile中加入<code>CMD [&quot;python&quot;,&quot;my_clock.py&quot;]</code>，重新构建镜像后，运行容器时后面不加任何命令，就会默认执行<code>python my_clock.py</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm chasonlee/ubuntu_demo:latest</span><br></pre></td></tr></table></figure><p>执行后就会每隔一秒钟输出一次系统时间。若我们在后面加入其它命令，就会替换默认的命令。</p><blockquote><p>敬请期待…</p></blockquote><ul><li><code>ENTRYPOINT</code></li><li><code>ARG</code></li><li><code>VOLUME</code></li><li><code>EXPOSE</code></li><li><code>USER</code></li><li><code>HEALTHCHECK</code></li><li><code>ONBUILD</code></li></ul><h3 id="三-构建镜像"><a class="header-anchor" href="#三-构建镜像">¶</a>三、构建镜像</h3><p>完成Dockerfile之后，便可在Dockerfile的目录中直接构建镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t ubuntu_demo:latest .</span><br></pre></td></tr></table></figure><ul><li><code>ubuntu_demo:latest</code>是构建的镜像名和标签，如需上传到Docker Hub，可以修改为<code>&lt;user name&gt;/&lt;image name&gt;:&lt;tag&gt;</code>形式。</li><li><code>.</code>最后一个参数指向Dockerfile所在的目录，这里是当前目录。</li></ul><p>执行后就会开始根据Dockerfile的内容构建镜像，需要等待一段时间，联网下载的部分命令耗时会比较长，读者如果需要安装TensorFlow之类安装包较大的库时，建议先下载好本地whl文件，用<code>COPY</code>命令复制到镜像中，用<code>RUN</code>命令安装并把whl文件删除。</p><p>如果构建失败，请查看Dockerfile中的命令是否有问题。如果成功，恭喜你已经掌握了基本的镜像构建方法！</p><p>执行<code>docker images</code>即可查看刚刚构建成功的镜像。</p><hr><h2 id="docker-hub使用"><a class="header-anchor" href="#docker-hub使用">¶</a>Docker Hub使用</h2><p>首先请到<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub官网</a>注册一个账号，每个账号都有一个免费的私有仓库，无限个公有仓库，私有仓库只有你自己能看到，如有需要可以购买更多私有仓库。</p><h3 id="一-登陆登出docker-hub"><a class="header-anchor" href="#一-登陆登出docker-hub">¶</a>一、登陆登出Docker Hub</h3><p>如果需要上传镜像到自己的Docker Hub，需要先在bash中登陆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure><p>之后输入自己的账号密码即可。</p><p>若需要登陆其他平台的仓库，在后面加上网址即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login &lt;url&gt;</span><br></pre></td></tr></table></figure><p>需要登出时可执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logout</span><br></pre></td></tr></table></figure><p>若需要登陆其他账号，可以加入<code>-u</code>参数，<code>-p</code>可以输入密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login -u 用户名 -p 密码</span><br></pre></td></tr></table></figure><h3 id="二-上传镜像"><a class="header-anchor" href="#二-上传镜像">¶</a>二、上传镜像</h3><p>与下载镜像<code>pull</code>相反，上传镜像用<code>push</code>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push &lt;user name&gt;/ubuntu_demo:latest</span><br></pre></td></tr></table></figure><ul><li><code>&lt;user name&gt;</code>是自己的用户名，如果构建镜像时，镜像名称前面忘记加用户名，请用<a href="http://chason.me/docker-tutorial/#6-%E4%BF%AE%E6%94%B9%E9%95%9C%E5%83%8F%E5%90%8D%E7%A7%B0%E5%8F%8A%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener"><code>docker tag</code></a>命令修改。</li></ul><p>镜像上传需要一定时间，取决于镜像大小和网速。上传成功后镜像默认存在私有仓库中，在<code>Setting</code>中<code>Make public</code>即可转为公开的仓库。</p><hr><h2 id="nvidia-docker"><a class="header-anchor" href="#nvidia-docker">¶</a>nvidia-docker</h2><p>Docker支持CUDA环境的隔绝，这是深度学习算法框架使用者的福音，因为TensorFlow的不同版本可能需要不同CUDA版本，这导致无法用<a href="http://chason.me/virtualenv-tutorial/" target="_blank" rel="noopener">virtualenv</a>在同一台机安装多个版本跨度较大的TensorFlow，有了Docker，这种问题就能迎刃而解。</p><p>基于前面的内容，读者可能会发现，在之前启动的Docker容器里面并不能执行<code>nvidia-smi</code>命令，无法使用GPU版本的TensorFlow或PyTorch。不用着急，现在我们开始学习如何配置一个带NVIDIA的Docker，只需在<a href="http://chason.me/docker-tutorial/#%E4%B8%80-%E5%AE%89%E8%A3%85docker" target="_blank" rel="noopener">安装Docker</a>的基础之上，继续安装nvidia-docker2即可，具体可参考<a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="noopener">nvidia-docker说明</a>，主要包含以下几个步骤：</p><h3 id="一-卸载旧版nvidia-docker"><a class="header-anchor" href="#一-卸载旧版nvidia-docker">¶</a>一、卸载旧版nvidia-docker</h3><blockquote><p>If you have nvidia-docker 1.0 installed: we need to remove it and all existing GPU containers</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls -q -f driver=nvidia-docker | xargs -r -I&#123;&#125; -n1 docker ps -q -a -f volume=&#123;&#125; | xargs -r docker rm -f</span><br><span class="line">sudo apt-get purge -y nvidia-docker</span><br></pre></td></tr></table></figure><h3 id="二-添加包源"><a class="header-anchor" href="#二-添加包源">¶</a>二、添加包源</h3><blockquote><p>Add the package repositories</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \</span><br><span class="line">  sudo apt-key add -</span><br><span class="line">distribution=$(. /etc/os-release;echo $ID$VERSION_ID)</span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \</span><br><span class="line">  sudo tee /etc/apt/sources.list.d/nvidia-docker.list</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h3 id="三-安装nvidia-docker2"><a class="header-anchor" href="#三-安装nvidia-docker2">¶</a>三、安装nvidia-docker2</h3><blockquote><p>Install nvidia-docker2 and reload the Docker daemon configuration</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y nvidia-docker2</span><br><span class="line">sudo pkill -SIGHUP dockerd</span><br></pre></td></tr></table></figure><h3 id="四-测试nvidia-docker"><a class="header-anchor" href="#四-测试nvidia-docker">¶</a>四、测试nvidia-docker</h3><p>安装完成后，我们可以在启动容器的命令前面加上<code>nvidia-</code>即可启动<strong>支持GPU的Docker</strong>。</p><p>首先，我们需要先下载一个自带CUDA的镜像，读者可以在<a href="https://hub.docker.com/" target="_blank" rel="noopener">DockerHub</a>里面自行寻找，或尝试这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nvidia/cuda:10.0-base-ubuntu16.04</span><br></pre></td></tr></table></figure><p>镜像拉回本地后，即可使用<code>nvidia-docker</code>命令创建容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-docker run -dit --name my_ubuntu_gpu nvidia/cuda:10.0-base-ubuntu16.04</span><br></pre></td></tr></table></figure><p>等同于加<code>--runtime=nvidia</code>，这种新的用法只有<strong>nvidia-docker v2</strong>支持：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --runtime=nvidia -dit --name my_ubuntu_gpu nvidia/cuda:10.0-base-ubuntu16.04</span><br></pre></td></tr></table></figure><p>为了加以区分，容器名后面加上了<code>_gpu</code>，进入容器的方法不变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it my_ubuntu_gpu bash</span><br></pre></td></tr></table></figure><p>现在进入容器后即可执行<code>nvidia-smi</code>查看GPU状态。</p><p>注意：nvidia-docker只是能让Docker支持GPU而已，Docker镜像需要同时带有CUDA才能使用GPU，如上面的<code>nvidia/cuda:10.0-base-ubuntu16.04</code>镜像，我们可以基于此定制自己的镜像。另外，也可以基于不带CUDA的镜像，先下载好CUDA安装包，然后在Dockerfile里面写好安装的命令，在构建镜像的过程中安装好CUDA（安装cuDNN也是同样的思路）。</p><hr><h2 id="结束语"><a class="header-anchor" href="#结束语">¶</a>结束语</h2><p>我们从镜像到容器、从运行到构建、从CPU到GPU，一步步学完了Docker的基本使用方法。笔者在本文以实例的方式讲述Docker的使用，是希望读者能以边读边实践方式进行学习，没人可以一次记住所有的命令，熟练的前提是反复不断地练习。另外，本文介绍的内容并非Docker的全部，更多内容有待读者自行探索<a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker官网文档</a>，未来我也会持续更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简介&quot;&gt;¶&lt;/a&gt;简介&lt;/h2&gt;
&lt;p&gt;Docker的诞生，让应用的部署变得前所未有的高效，它能将应用及其依赖项打包成容器分发部署，从而保证了应用运行环境的一致性。Docker容器其实是一种比虚拟机更轻量的技术，容器中的进程直接运行在宿主机的内核，其启动速度十分快，基本可以做到秒级启动，并不像虚拟机那样对硬件进行模拟，并在之上运行一整套操作系统，所以容器相比虚拟机更为轻便。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://chason.pro/categories/Linux/"/>
    
    
      <category term="Docker" scheme="http://chason.pro/tags/Docker/"/>
    
      <category term="Ubuntu" scheme="http://chason.pro/tags/Ubuntu/"/>
    
      <category term="镜像" scheme="http://chason.pro/tags/%E9%95%9C%E5%83%8F/"/>
    
      <category term="容器" scheme="http://chason.pro/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="CUDA" scheme="http://chason.pro/tags/CUDA/"/>
    
      <category term="深度学习" scheme="http://chason.pro/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>零基础机器学习入门</title>
    <link href="http://chason.pro/machine-learning-101/"/>
    <id>http://chason.pro/machine-learning-101/</id>
    <published>2019-05-07T16:00:00.000Z</published>
    <updated>2019-06-02T16:19:41.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#概述&quot;&gt;¶&lt;/a&gt;概述&lt;/h2&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://chason.pro/categories/Machine-Learning/"/>
    
    
      <category term="机器学习" scheme="http://chason.pro/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>如何在终端显示图片</title>
    <link href="http://chason.pro/how-to-display-images-in-the-terminal/"/>
    <id>http://chason.pro/how-to-display-images-in-the-terminal/</id>
    <published>2019-05-07T16:00:00.000Z</published>
    <updated>2019-05-19T14:45:24.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>是否遇到过这样的情况，你希望能查看服务器中的图片大致是什么样子，却只能通过终端SSH登陆服务器，而无法直接下载里面的图片到本地。本文介绍的工具<a href="https://github.com/stefanhaustein/TerminalImageViewer" target="_blank" rel="noopener">Terminal Image Viewer</a>就能在终端命令行中显示图片，原理其实就是直接用色块打印出图片的内容，由于分辨率有限，只能近似地显示图片缩略图。</p><a id="more"></a><h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2><p>根据官方的介绍，先用命令安装<code>imagemagick</code>，再用<code>make</code>编译安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install imagemagick || yum install ImageMagick</span><br><span class="line">git clone https://github.com/stefanhaustein/TerminalImageViewer.git</span><br><span class="line">cd TerminalImageViewer/src/main/cpp</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h2><p>命令行中直接输入tiv即可查看使用说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">usage: tiv [options] &lt;image&gt; [&lt;image&gt;...]</span><br><span class="line"></span><br><span class="line">  -0        : No block character adjustment, always use top half block char.</span><br><span class="line">  -256      : Use 256 color mode.</span><br><span class="line">  -c &lt;num&gt;  : Number of thumbnail columns in &apos;dir&apos; mode (3).</span><br><span class="line">  -d        : Force &apos;dir&apos; mode. Automatially selected for more than one input.</span><br><span class="line">  -f        : Force &apos;full&apos; mode. Automatically selected for one input.</span><br><span class="line">  -help     : Display this help text.</span><br><span class="line">  -h &lt;num&gt;  : Set the maximum height to &lt;num&gt; lines.</span><br><span class="line">  -w &lt;num&gt;  : Set the maximum width to &lt;num&gt; characters.</span><br></pre></td></tr></table></figure><p>例如：我想查看当前目录中，一个名为<code>n03792782_55532.JPEG</code>的图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tiv n03792782_55532.JPEG</span><br></pre></td></tr></table></figure><img src="/how-to-display-images-in-the-terminal/bike.jpg" title="显示效果"><img src="/how-to-display-images-in-the-terminal/src_bike.JPEG" title="原图"><p>使用通配符就可以同时显示多张图片:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tiv n03792782_555*</span><br></pre></td></tr></table></figure><img src="/how-to-display-images-in-the-terminal/bikes.jpg" title="显示效果"><p>另外两张原图：</p><img src="/how-to-display-images-in-the-terminal/src_bike1.JPEG" title="原图"><img src="/how-to-display-images-in-the-terminal/src_bike3.JPEG" title="原图"><p>从显示效果上看，文字等细节是看不清楚的，当成缩略图来看即可，掌握此工具即可在命令行中浏览图片缩略图，有需要的同学收藏起来吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#概述&quot;&gt;¶&lt;/a&gt;概述&lt;/h2&gt;
&lt;p&gt;是否遇到过这样的情况，你希望能查看服务器中的图片大致是什么样子，却只能通过终端SSH登陆服务器，而无法直接下载里面的图片到本地。本文介绍的工具&lt;a href=&quot;https://github.com/stefanhaustein/TerminalImageViewer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Terminal Image Viewer&lt;/a&gt;就能在终端命令行中显示图片，原理其实就是直接用色块打印出图片的内容，由于分辨率有限，只能近似地显示图片缩略图。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://chason.pro/categories/Linux/"/>
    
    
      <category term="tiv" scheme="http://chason.pro/tags/tiv/"/>
    
      <category term="SSH" scheme="http://chason.pro/tags/SSH/"/>
    
      <category term="终端显示图片" scheme="http://chason.pro/tags/%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/"/>
    
      <category term="Terminal Image Viewer" scheme="http://chason.pro/tags/Terminal-Image-Viewer/"/>
    
  </entry>
  
  <entry>
    <title>virtualenv教程</title>
    <link href="http://chason.pro/virtualenv-tutorial/"/>
    <id>http://chason.pro/virtualenv-tutorial/</id>
    <published>2018-08-02T16:00:00.000Z</published>
    <updated>2019-05-24T14:26:58.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2><p>在<a href="https://chasonlee.github.io/server-configuration-tutorial/" target="_blank" rel="noopener">配置Linux服务器</a>时，为确保系统环境的稳定，或者为了在同一台机兼容安装不同版本的Python第三方库（TensorFlow、PyTorch）时，你就需要一个独立的虚拟环境隔绝系统环境。</p><p>需要注意的是，virtualenv只能隔绝Python环境，CUDA环境还是会和系统环境共用，如果需要独立的CUDA环境，请到笔者另一篇博文学习如何使用<a href="http://chason.me/docker-tutorial/" target="_blank" rel="noopener">Docker</a>。</p><a id="more"></a><h2 id="安装virtualenv"><a class="header-anchor" href="#安装virtualenv">¶</a>安装virtualenv</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y virtualenv</span><br></pre></td></tr></table></figure><h2 id="创建虚拟环境"><a class="header-anchor" href="#创建虚拟环境">¶</a>创建虚拟环境</h2><p>在自己的服务器中创建一个专门存放虚拟环境的文件夹，假设是<code>~/chason/venv</code>，进入此文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/chason/venv</span><br></pre></td></tr></table></figure><p>接下来为虚拟环境命名，假设我们要一个安装Python3、TensorFlow1.4的环境，为了方便以后容易想起这个虚拟环境的内容，可以命名为<code>py3tf1.4</code></p><p>创建一个默认采用Python3的虚拟环境:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv -p /usr/bin/python3.5 py3tf1.4</span><br></pre></td></tr></table></figure><p>其中<code>-p /usr/bin/python3.5</code>设置默认使用Python3，<code>py3tf1.4</code>是虚拟环境名称，此时会在<code>venv</code>文件夹下自动新建<code>py3tf1.4</code>文件夹</p><p>以后如有需要可以在<code>venv</code>文件夹下继续创建新的独立虚拟环境，如<code>py2tf1.3</code>等等。</p><h2 id="激活虚拟环境"><a class="header-anchor" href="#激活虚拟环境">¶</a>激活虚拟环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source py3tf1.4/bin/activate</span><br></pre></td></tr></table></figure><p>虚拟环境激活成功后，bash的前面会出现<code>(py3tf1.4)</code>，这就说明你已经进入了虚拟环境：<br><code>(py3tf1.4) [root@localhost ~]#</code></p><p>此时可以在虚拟环境中安装自己想要的包，并在此虚拟环境中运行自己的程序。</p><h2 id="停止虚拟环境"><a class="header-anchor" href="#停止虚拟环境">¶</a>停止虚拟环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><p>执行此语句后，<code>(py3tf1.4)</code>就会消失，说明已经退出虚拟环境，回到系统环境中：<br><code>[root@localhost ~]#</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简介&quot;&gt;¶&lt;/a&gt;简介&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://chasonlee.github.io/server-configuration-tutorial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;配置Linux服务器&lt;/a&gt;时，为确保系统环境的稳定，或者为了在同一台机兼容安装不同版本的Python第三方库（TensorFlow、PyTorch）时，你就需要一个独立的虚拟环境隔绝系统环境。&lt;/p&gt;
&lt;p&gt;需要注意的是，virtualenv只能隔绝Python环境，CUDA环境还是会和系统环境共用，如果需要独立的CUDA环境，请到笔者另一篇博文学习如何使用&lt;a href=&quot;http://chason.me/docker-tutorial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://chason.pro/categories/Linux/"/>
    
    
      <category term="TensorFlow" scheme="http://chason.pro/tags/TensorFlow/"/>
    
      <category term="PyTorch" scheme="http://chason.pro/tags/PyTorch/"/>
    
      <category term="virtualenv" scheme="http://chason.pro/tags/virtualenv/"/>
    
      <category term="Python" scheme="http://chason.pro/tags/Python/"/>
    
      <category term="虚拟环境" scheme="http://chason.pro/tags/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>tmux教程</title>
    <link href="http://chason.pro/tmux-tutorial/"/>
    <id>http://chason.pro/tmux-tutorial/</id>
    <published>2018-07-10T16:00:00.000Z</published>
    <updated>2019-05-21T14:50:29.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2><p>当你需要长期稳定在Linux（本文以Ubuntu为例）上运行SSH命令时，为了避免SSH连接中断造成的程序中断，需要使用<strong>tmux</strong>或者<a href="https://chasonlee.github.io/using-screen/" target="_blank" rel="noopener">screen</a>，笔者目前认为tmux更好用，所以本文将详细介绍tmux的使用方法。</p><p>tmux有三个概念：会话、窗口和面板，一个会话中可以存在多个窗口，一个窗口中可以存在多个面板，这种多级显示的方式可以让我们井然有序地在多种任务之间切换。</p><a id="more"></a><h2 id="一-安装tmux"><a class="header-anchor" href="#一-安装tmux">¶</a>一、安装tmux</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y tmux</span><br></pre></td></tr></table></figure><h2 id="二-基本用法-会话操作"><a class="header-anchor" href="#二-基本用法-会话操作">¶</a>二、基本用法（会话操作）</h2><p>当你只需要执行一个任务时，掌握好会话操作即可。</p><h3 id="1-新建会话"><a class="header-anchor" href="#1-新建会话">¶</a>1、新建会话</h3><p>在Shell中执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new -s chason</span><br></pre></td></tr></table></figure><p>其中chason可以改为自己需要的名字；新建会话后，即可在会话中执行自己的任务。</p><img src="/tmux-tutorial/new_session.jpg" title="新建会话后的界面"><h3 id="2-脱离会话"><a class="header-anchor" href="#2-脱离会话">¶</a>2、脱离会话</h3><p>脱离会话快捷键：<code>Ctrl+b d</code>，意思是：先按<code>Ctrl+b</code>，<strong>松手</strong>后再按<code>d</code>，脱离会话后就会返回之前的Shell界面。</p><p>执行<code>tmux detach</code>也可以脱离会话，但个人觉得用快捷键更方便快捷。</p><h3 id="3-显示会话"><a class="header-anchor" href="#3-显示会话">¶</a>3、显示会话</h3><p>在Shell中执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux ls</span><br></pre></td></tr></table></figure><p>将显示当前存在的会话。</p><h3 id="4-恢复会话"><a class="header-anchor" href="#4-恢复会话">¶</a>4、恢复会话</h3><p>在Shell中执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux attach</span><br></pre></td></tr></table></figure><p>或者简写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux a</span><br></pre></td></tr></table></figure><p>执行后就会进入上一次脱离的会话；另外，也可以直接恢复指定的会话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux a -t chason</span><br></pre></td></tr></table></figure><h3 id="4-切换会话"><a class="header-anchor" href="#4-切换会话">¶</a>4、切换会话</h3><p>在进入tmux会话之后，按快捷键<code>Ctrl+b s</code>即可直接显示当前存在会话，用上下方向键选择，回车即可切换到当前选择的会话。</p><h3 id="5-关闭会话"><a class="header-anchor" href="#5-关闭会话">¶</a>5、关闭会话</h3><p>关闭会话有几种方法：</p><ul><li>在会话中，如果只有一个窗口、一个面板，直接输入<code>exit</code>并回车，即可关闭当前会话。</li><li>在会话中，如果有不止一个窗口或面板，按快捷键<code>Ctrl+b :</code>后，输入命令<code>kill-session</code>，即可关闭当前会话。</li><li>在会话外的bash中，输入<code>tmux kill-session -t chason</code>，即可在tmux外关闭指定会话。</li></ul><h2 id="三-进阶用法-窗口-面板操作"><a class="header-anchor" href="#三-进阶用法-窗口-面板操作">¶</a>三、进阶用法（窗口、面板操作）</h2><h3 id="1-窗口操作"><a class="header-anchor" href="#1-窗口操作">¶</a>1、窗口操作</h3><p>在基本用法中，新建一个会话默认只有一个窗口，实际上，在一个会话中可以创建多个窗口，从而实现更好的层级管理。</p><h4 id="新建窗口"><a class="header-anchor" href="#新建窗口">¶</a>新建窗口</h4><p>快捷键<code>Ctrl+b c</code>会在当前会话中新建一个窗口。</p><img src="/tmux-tutorial/new_window.jpg" title="存在两个窗口的界面"><p>在下面绿色任务栏中可见两个bash，后面带*的是当前窗口，当前在窗口1（数字从0开始）。</p><h4 id="切换窗口"><a class="header-anchor" href="#切换窗口">¶</a>切换窗口</h4><p><code>Ctrl+b n</code>切换下一个窗口，<code>Ctrl+b p</code>切换上一个窗口，头尾窗口之间会循环切换，切换窗口的时候*会随之移动指示当前在哪个窗口。</p><h4 id="关闭窗口"><a class="header-anchor" href="#关闭窗口">¶</a>关闭窗口</h4><p>在窗口中输入<code>exit</code>并回车即可关闭当前窗口，或使用快捷键<code>Ctrl+b &amp;</code>，按下后会提示是否关闭窗口，输入y即可关闭当前窗口。</p><h3 id="2-面板操作"><a class="header-anchor" href="#2-面板操作">¶</a>2、面板操作</h3><p>默认一个窗口只有一个面板，当需要同时查看多个程序的内容时，可以把当前窗口分割成多个面板。</p><h4 id="新建面板"><a class="header-anchor" href="#新建面板">¶</a>新建面板</h4><p><code>Ctrl+b &quot;</code>将当前窗口平分为上下两块面板，<code>Ctrl+b %</code>将当前窗口平分为左右两块面板。</p><img src="/tmux-tutorial/new_panel.jpg" title="在第二个窗口新建左右分割面板"><p>面板分割最大的好处就是可以同时查看不同命令的结果，比如左边调试代码，右边实时显示内存、CPU情况等。</p><img src="/tmux-tutorial/more_panel.jpg" title="上下分割右边的面板"><p>读者可以按照自己的需求随意分割，设计自己喜欢的面板样式。</p><h4 id="切换面板"><a class="header-anchor" href="#切换面板">¶</a>切换面板</h4><p><code>Ctrl+b 方向键</code>即可移动光标选择不同面板。</p><h4 id="关闭面板"><a class="header-anchor" href="#关闭面板">¶</a>关闭面板</h4><p>在面板中输入<code>exit</code>并回车即可关闭当前面板，或者使用快捷键<code>Ctrl+b x</code>，按下后会提示是否关闭面板，输入y即可关闭当前面板。</p><p><em>更多操作方法请参考如下常用快捷键</em></p><h2 id="四-高阶用法-常用快捷键"><a class="header-anchor" href="#四-高阶用法-常用快捷键">¶</a>四、高阶用法（常用快捷键）</h2><h3 id="会话操作"><a class="header-anchor" href="#会话操作">¶</a>会话操作</h3><p><code>Ctrl+b $</code> 修改会话名字</p><p><code>Ctrl+b d</code> 脱离当前会话，返回Shell界面，输入<code>tmux a</code>能够重新进入之前的会话</p><p><code>Ctrl+b s</code> 选择并切换会话，在创建了多个会话时使用</p><p><code>Ctrl+b [</code> 进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出</p><p><code>Ctrl+b ?</code> 列出所有快捷键，按q返回</p><h3 id="窗口操作"><a class="header-anchor" href="#窗口操作">¶</a>窗口操作</h3><p><code>Ctrl+b c</code> 在会话中新建窗口</p><p><code>Ctrl+b n</code> 切换下一个窗口</p><p><code>Ctrl+b p</code> 切换上一个窗口</p><p><code>Ctrl+b l</code> 在前后两个窗口间互相切换</p><p><code>Ctrl+b 数字键</code> 切换至指定窗口</p><p><code>Ctrl+b w</code> 通过窗口列表切换窗口</p><p><code>Ctrl+b ,</code> 修改窗口名字</p><p><code>Ctrl+b .</code> 修改当前窗口编号；相当于窗口重新排序</p><p><code>Ctrl+b &amp;</code> 关闭当前窗口</p><p><code>Ctrl+b f</code> 在所有窗口中查找指定文本</p><h3 id="面板操作"><a class="header-anchor" href="#面板操作">¶</a>面板操作</h3><p><code>Ctrl+b &quot;</code> 将当前窗口平分为上下两块面板</p><p><code>Ctrl+b %</code> 将当前窗口平分为左右两块面板</p><p><code>Ctrl+b x</code> 关闭当前面板</p><p><code>Ctrl+b !</code> 将当前面板置于新窗口，即新建一个窗口，其中仅包含当前面板</p><p><code>Ctrl+b q</code> 显示面板编号</p><p><code>Ctrl+b o</code> 在当前窗口中选择下一面板</p><p><code>Ctrl+b 方向键</code> 移动光标以选择面板</p><p><code>Ctrl+b {</code> 向前置换当前面板</p><p><code>Ctrl+b }</code> 向后置换当前面板</p><p><code>Ctrl+b Alt+o</code> 逆时针旋转当前窗口的面板</p><p><code>Ctrl+b Ctrl+o</code> 顺时针旋转当前窗口的面板</p><p><code>Ctrl+b Space</code> 在预置的面板布局中循环切换，依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简介&quot;&gt;¶&lt;/a&gt;简介&lt;/h2&gt;
&lt;p&gt;当你需要长期稳定在Linux（本文以Ubuntu为例）上运行SSH命令时，为了避免SSH连接中断造成的程序中断，需要使用&lt;strong&gt;tmux&lt;/strong&gt;或者&lt;a href=&quot;https://chasonlee.github.io/using-screen/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;screen&lt;/a&gt;，笔者目前认为tmux更好用，所以本文将详细介绍tmux的使用方法。&lt;/p&gt;
&lt;p&gt;tmux有三个概念：会话、窗口和面板，一个会话中可以存在多个窗口，一个窗口中可以存在多个面板，这种多级显示的方式可以让我们井然有序地在多种任务之间切换。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://chason.pro/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="http://chason.pro/tags/Ubuntu/"/>
    
      <category term="SSH" scheme="http://chason.pro/tags/SSH/"/>
    
      <category term="tmux" scheme="http://chason.pro/tags/tmux/"/>
    
      <category term="会话" scheme="http://chason.pro/tags/%E4%BC%9A%E8%AF%9D/"/>
    
      <category term="窗口" scheme="http://chason.pro/tags/%E7%AA%97%E5%8F%A3/"/>
    
      <category term="面板" scheme="http://chason.pro/tags/%E9%9D%A2%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>Linux挂载磁盘</title>
    <link href="http://chason.pro/mounting-drives-in-linux/"/>
    <id>http://chason.pro/mounting-drives-in-linux/</id>
    <published>2018-01-05T16:00:00.000Z</published>
    <updated>2019-05-15T15:37:51.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2><p>本文介绍如何用Linux命令临时挂载U盘以及永久挂载硬盘。</p><a id="more"></a><h2 id="一-挂载u盘"><a class="header-anchor" href="#一-挂载u盘">¶</a>一、挂载U盘</h2><h3 id="1-确认u盘名"><a class="header-anchor" href="#1-确认u盘名">¶</a>1、确认U盘名</h3><p>将U盘插入后，显示所有设备信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure><p>可以根据U盘大小，找到U盘对应的挂载名，假设是<code>/dev/sdb1</code></p><h3 id="2-挂载"><a class="header-anchor" href="#2-挂载">¶</a>2、挂载</h3><p>假设要挂载到<code>/media</code>，确保文件夹存在后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sdb1 /media</span><br></pre></td></tr></table></figure><p>使用命令<code>df -h</code>即可查看当前挂载的所有磁盘以及空间使用情况</p><h3 id="3-卸载"><a class="header-anchor" href="#3-卸载">¶</a>3、卸载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /media</span><br></pre></td></tr></table></figure><p>输入<code>df -h</code>可以确认U盘已经卸载</p><h2 id="二-挂载硬盘"><a class="header-anchor" href="#二-挂载硬盘">¶</a>二、挂载硬盘</h2><h3 id="1-确认硬盘名"><a class="header-anchor" href="#1-确认硬盘名">¶</a>1、确认硬盘名</h3><p>接好硬盘后，显示所有设备信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure><p>假设需要挂载的磁盘为<code>sda</code>，而且其下面没有分区（如<code>sda1</code>）</p><h3 id="2-建立分区"><a class="header-anchor" href="#2-建立分区">¶</a>2、建立分区</h3><p>如果是新硬盘，需要新建分区并格式化硬盘（<strong>如果硬盘已经有数据，请先备份，谨慎操作</strong>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk /dev/sda</span><br></pre></td></tr></table></figure><p>输入<code>m</code>可以查看帮助:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Command action</span><br><span class="line">   a   toggle a bootable flag      #设定可启动标记</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition          #删除一个分区</span><br><span class="line">   l   list known partition types  #各分区类型所对应的ID</span><br><span class="line">   m   print this menu             #查看帮助</span><br><span class="line">   n   add a new partition         #添加一个分区</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   print the partition table   #显示该磁盘下的当前分区信息</span><br><span class="line">   q   quit without saving changes #不保存退出</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition&apos;s system id</span><br><span class="line">   u   change display/entry units</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   w   write table to disk and exit#保存退出</span><br><span class="line">   x   extra functionality (experts only)</span><br></pre></td></tr></table></figure><p>可以按照以下步骤输入指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n    新建分区</span><br><span class="line">p    创建逻辑分区</span><br><span class="line">1    创建一个分区</span><br><span class="line">w    保存</span><br></pre></td></tr></table></figure><p>此时再查看设备信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure><p>就可以看到已经建立了分区<code>/dev/sda1</code></p><h3 id="3-格式化分区"><a class="header-anchor" href="#3-格式化分区">¶</a>3、格式化分区</h3><p>假如分区格式不是ext4，可以先格式化为ext4（<strong>注意！此操作会清空硬盘数据，如果硬盘已经有数据，请先备份</strong>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfs.ext4 /dev/sda1</span><br></pre></td></tr></table></figure><h3 id="4-挂载到指定目录"><a class="header-anchor" href="#4-挂载到指定目录">¶</a>4、挂载到指定目录</h3><p>假设要挂载到<code>~/hdd</code>目录下，请先创建此目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/hdd</span><br></pre></td></tr></table></figure><p>然后挂载分区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sda1 ~/hdd</span><br></pre></td></tr></table></figure><p>输入<code>df -h</code>可查看当前挂载分区，及其空间使用情况</p><h3 id="5-配置开机自动挂载"><a class="header-anchor" href="#5-配置开机自动挂载">¶</a>5、配置开机自动挂载</h3><p>注意以上操作是临时挂载硬盘，机器重启后需要重新挂载，若想让机器每次启动自动挂载硬盘，需要修改配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br></pre></td></tr></table></figure><p>在文件末尾加入（假设<code>~=/home/chason</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/sda1 /home/chason/hdd ext4 defaults 0 0</span><br></pre></td></tr></table></figure><p>最后重启即可验证机器已经实现自动挂载硬盘。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简介&quot;&gt;¶&lt;/a&gt;简介&lt;/h2&gt;
&lt;p&gt;本文介绍如何用Linux命令临时挂载U盘以及永久挂载硬盘。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://chason.pro/categories/Linux/"/>
    
    
      <category term="mount" scheme="http://chason.pro/tags/mount/"/>
    
      <category term="fdisk" scheme="http://chason.pro/tags/fdisk/"/>
    
      <category term="挂载磁盘" scheme="http://chason.pro/tags/%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器配置教程</title>
    <link href="http://chason.pro/server-configuration-tutorial/"/>
    <id>http://chason.pro/server-configuration-tutorial/</id>
    <published>2017-08-17T16:00:00.000Z</published>
    <updated>2019-05-15T15:37:30.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>本文详细介绍了几种算法库在Linux环境（本文以Ubuntu为例）的安装过程以及常见问题的解决方法，包括OpenCV、Caffe、TensorFlow和PyTorch。</p><a id="more"></a><h2 id="opencv源码安装"><a class="header-anchor" href="#opencv源码安装">¶</a>OpenCV源码安装</h2><h3 id="1-更新软件库"><a class="header-anchor" href="#1-更新软件库">¶</a>1、更新软件库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h3 id="2-安装依赖项"><a class="header-anchor" href="#2-安装依赖项">¶</a>2、安装依赖项</h3><p>复制执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --assume-yes build-essential cmake git</span><br><span class="line">sudo apt-get install --assume-yes pkg-config unzip ffmpeg qtbase5-dev python-dev python3-dev python-numpy python3-numpy</span><br><span class="line">sudo apt-get install --assume-yes libopencv-dev libgtk-3-dev libdc1394-22 libdc1394-22-dev libjpeg-dev libpng12-dev libtiff5-dev libjasper-dev</span><br><span class="line">sudo apt-get install --assume-yes libavcodec-dev libavformat-dev libswscale-dev libxine2-dev libgstreamer0.10-dev libgstreamer-plugins-base0.10-dev</span><br><span class="line">sudo apt-get install --assume-yes libv4l-dev libtbb-dev libfaac-dev libmp3lame-dev libopencore-amrnb-dev libopencore-amrwb-dev libtheora-dev</span><br><span class="line">sudo apt-get install --assume-yes libvorbis-dev libxvidcore-dev v4l-utils python-vtk</span><br><span class="line">sudo apt-get install --assume-yes liblapacke-dev libopenblas-dev checkinstall</span><br><span class="line">sudo apt-get install --assume-yes libgdal-dev</span><br></pre></td></tr></table></figure><h3 id="3-安装cuda和cudnn"><a class="header-anchor" href="#3-安装cuda和cudnn">¶</a>3、安装Cuda和CuDNN</h3><p>参考网上的教程<a href="https://github.com/BVLC/caffe/wiki/Ubuntu-16.04-or-15.10-Installation-Guide#the-gpu-support-prerequisites" target="_blank" rel="noopener">The GPU support prerequisites</a></p><h3 id="4-下载源码"><a class="header-anchor" href="#4-下载源码">¶</a>4、下载源码</h3><p>去到自己指定的目录下，下载OpenCV3.2的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">wget https://github.com/opencv/opencv/archive/3.2.0.zip</span><br></pre></td></tr></table></figure><h3 id="5-编译源码"><a class="header-anchor" href="#5-编译源码">¶</a>5、编译源码</h3><p>首先解压源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip 3.2.0.zip</span><br></pre></td></tr></table></figure><p>进入OpenCV目录，创建build文件夹，并开始编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd opencv-3.2.0</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D INSTALL_PYTHON_EXAMPLES=ON -D INSTALL_C_EXAMPLES=OFF -D PYTHON_EXCUTABLE=/usr/bin/python -D WITH_CUDA=ON -D WITH_CUBLAS=ON -D DCUDA_NVCC_FLAGS=&quot;-D_FORCE_INLINES&quot; -D CUDA_ARCH_PTX=&quot;&quot; -D WITH_TBB=ON -D WITH_V4L=ON -D WITH_OPENGL=ON -D BUILD_EXAMPLES=ON ..</span><br><span class="line">make -j$(nproc)</span><br></pre></td></tr></table></figure><h3 id="6-编译安装"><a class="header-anchor" href="#6-编译安装">¶</a>6、编译安装</h3><p>编译完成后即可安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo make install -j$(nproc)</span><br><span class="line">sudo /bin/bash -c &apos;echo &quot;/usr/local/lib&quot; &gt; /etc/ld.so.conf.d/opencv.conf&apos;</span><br><span class="line">sudo ldconfig</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h3 id="7-常见问题"><a class="header-anchor" href="#7-常见问题">¶</a>7、常见问题</h3><ul><li>编译过程中如果ippicv文件下载失败，可以自行<a href="https://github.com/opencv/opencv_3rdparty/tree/ippicv/master_20151201/ippicv" target="_blank" rel="noopener">下载</a>，拷贝到<code>opencv-3.2.0/3rdparty/ippicv/downloads/linux-808b791a6eac9ed78d32a7666804320e</code>目录下</li></ul><h2 id="caffe源码安装"><a class="header-anchor" href="#caffe源码安装">¶</a>Caffe源码安装</h2><h3 id="1-下载caffe源码"><a class="header-anchor" href="#1-下载caffe源码">¶</a>1、下载Caffe源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">git clone https://github.com/BVLC/caffe.git</span><br></pre></td></tr></table></figure><h3 id="2-安装依赖项-v2"><a class="header-anchor" href="#2-安装依赖项-v2">¶</a>2、安装依赖项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --assume-yes libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler</span><br><span class="line">sudo apt-get install --assume-yes --no-install-recommends libboost-all-dev</span><br><span class="line">sudo apt-get install --assume-yes libgflags-dev libgoogle-glog-dev liblmdb-dev</span><br></pre></td></tr></table></figure><h3 id="3-安装blas"><a class="header-anchor" href="#3-安装blas">¶</a>3、安装BLAS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --assume-yes libatlas-base-dev</span><br></pre></td></tr></table></figure><h3 id="4-cmake编译"><a class="header-anchor" href="#4-cmake编译">¶</a>4、CMake编译</h3><p>若未安装vim，则先安装vim：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --assume-yes vim</span><br></pre></td></tr></table></figure><p>进入caffe目录，复制配置文件，并修改配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd caffe</span><br><span class="line">cp Makefile.config.example Makefile.config</span><br><span class="line">vim Makefile.config</span><br></pre></td></tr></table></figure><p><strong>注意，Caffe的配置信息需要进行一定修改，否则会造成编译出错。</strong></p><ol><li>如果需要使用CuDNN，则取消<code>USE_CUDNN := 1</code>的注释</li><li>如果需要使用OpenCV3，则取消<code>OPENCV_VERSION := 3</code>的注释</li><li>如果需要使用Python，则取消<code>WITH_PYTHON_LAYER := 1</code>的注释</li><li>在<strong>Makefile.config</strong>的94行，需要进行如下修改，否则会有hdf5无法找到的错误：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include</span><br><span class="line">+++ INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serial/</span><br></pre></td></tr></table></figure><pre><code>其中`---`代表删除本行，`+++`代表增加本行。</code></pre><p>另外，<strong>Makefile</strong>也需要修改181行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim Makefile</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- LIBRARIES += glog gflags protobuf boost_system boost_filesystem m hdf5_hl hdf5</span><br><span class="line">+++ LIBRARIES += glog gflags protobuf boost_system boost_filesystem m hdf5_serial_hl hdf5_serial</span><br></pre></td></tr></table></figure><p>修改完后即可用CMake编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make all -j$(nproc)</span><br><span class="line">make install -j$(nproc)</span><br><span class="line">make runtest -j$(nproc)</span><br></pre></td></tr></table></figure><p>若需要在Python中调用，则执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make pycaffe -j$(nproc)</span><br></pre></td></tr></table></figure><p>最后还需要添加路径到PYTHONPATH中，打开.bashrc文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>在.bashrc的最后一行添加实际的caffe/python的路径，（注意：需要按照实际情况修改路径）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PYTHONPATH=&quot;$PYTHONPATH:/&lt;your/path&gt;/caffe/python&quot;</span><br></pre></td></tr></table></figure><p>并让其生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>现在便可以在Python中import caffe，测试能否成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">import caffe</span><br></pre></td></tr></table></figure><h3 id="5-常见问题"><a class="header-anchor" href="#5-常见问题">¶</a>5、常见问题</h3><ul><li><p><code>ImportError: dynamic module does not define init function (init_caffe)</code></p><p>当前Python版本和编译时Python版本不一致，需要一致使用Python2或者Python3</p></li><li><p><code>F0108 20:21:26.907105 15849 pooling_layer.cu:212] Check failed: error == cudaSuccess (8 vs. 0) invalid device function</code></p><p>编译配置中算力选择与当前设备算力不一致，参考<a href="https://developer.nvidia.com/cuda-gpus#collapseOne" target="_blank" rel="noopener">官方显卡算力表</a></p></li></ul><h2 id="tensorflow虚拟环境安装"><a class="header-anchor" href="#tensorflow虚拟环境安装">¶</a>TensorFlow虚拟环境安装</h2><h3 id="1-下载指定版本源码"><a class="header-anchor" href="#1-下载指定版本源码">¶</a>1、下载指定版本源码</h3><p>在自定义目录中下载源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir virtual-env</span><br><span class="line">cd virtual-env</span><br><span class="line">git clone https://github.com/tensorflow/tensorflow</span><br></pre></td></tr></table></figure><p>选择指定版本，比如r1.0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd tensorflow</span><br><span class="line">git checkout r1.0</span><br></pre></td></tr></table></figure><h3 id="2-安装依赖项-v3"><a class="header-anchor" href="#2-安装依赖项-v3">¶</a>2、安装依赖项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip python-dev python-virtualenv # for Python 2.7</span><br><span class="line">sudo apt-get install python3-pip python3-dev python-virtualenv # for Python 3.n</span><br></pre></td></tr></table></figure><h3 id="3-创建虚拟环境"><a class="header-anchor" href="#3-创建虚拟环境">¶</a>3、创建虚拟环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virtualenv --system-site-packages ~/virtual-env/tensorflow # for Python 2.7</span><br><span class="line">virtualenv --system-site-packages -p python3 ~/virtual-env/tensorflow # for Python 3.n</span><br></pre></td></tr></table></figure><h3 id="4-激活虚拟环境"><a class="header-anchor" href="#4-激活虚拟环境">¶</a>4、激活虚拟环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/virtual-env/tensorflow/bin/activate</span><br></pre></td></tr></table></figure><h3 id="5-安装tensorflow"><a class="header-anchor" href="#5-安装tensorflow">¶</a>5、安装TensorFlow</h3><ul><li>Python2.7 CPU only</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-1.0.1-cp27-none-linux_x86_64.whl</span><br></pre></td></tr></table></figure><ul><li>Python2.7 GPU</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow_gpu-1.0.1-cp27-none-linux_x86_64.whl</span><br></pre></td></tr></table></figure><ul><li>Python3.4 CPU only</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-1.0.1-cp34-cp34m-linux_x86_64.whl</span><br></pre></td></tr></table></figure><ul><li>Python3.4 GPU</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow_gpu-1.0.1-cp34-cp34m-linux_x86_64.whl</span><br></pre></td></tr></table></figure><ul><li>Python3.5 CPU only</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-1.0.1-cp35-cp35m-linux_x86_64.whl</span><br></pre></td></tr></table></figure><ul><li>Python3.5 GPU</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow_gpu-1.0.1-cp35-cp35m-linux_x86_64.whl</span><br></pre></td></tr></table></figure><h3 id="6-验证安装结果"><a class="header-anchor" href="#6-验证安装结果">¶</a>6、验证安装结果</h3><p>TensorFlow已经安装完毕，现在可以测试安装是否成功。<br>首先要注意退出tensorflow的目录，否则会出现<code>ImportError: cannot import name pywrap_tensorflow</code>的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">python</span><br></pre></td></tr></table></figure><p>输入以下Python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">hello = tf.constant(<span class="string">'Hello, TensorFlow!'</span>)</span><br><span class="line">sess = tf.Session()</span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure><h2 id="tensorflow源码安装"><a class="header-anchor" href="#tensorflow源码安装">¶</a>TensorFlow源码安装</h2><h3 id="1-下载指定版本源码-v2"><a class="header-anchor" href="#1-下载指定版本源码-v2">¶</a>1、下载指定版本源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tensorflow/tensorflow</span><br></pre></td></tr></table></figure><p>选择指定版本，比如r1.0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd tensorflow</span><br><span class="line">git checkout r1.0</span><br></pre></td></tr></table></figure><h3 id="2-安装bazel"><a class="header-anchor" href="#2-安装bazel">¶</a>2、安装Bazel</h3><p>安装JDK8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --assume-yes openjdk-8-jdk</span><br></pre></td></tr></table></figure><p>若未安装curl，则先安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --assume-yes curl</span><br></pre></td></tr></table></figure><p>添加包源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb [arch=amd64] http://storage.googleapis.com/bazel-apt stable jdk1.8&quot; | sudo tee /etc/apt/sources.list.d/bazel.list</span><br><span class="line">curl https://bazel.build/bazel-release.pub.gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>更新并安装Bazel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install --assume-yes bazel</span><br></pre></td></tr></table></figure><h3 id="3-安装python依赖项"><a class="header-anchor" href="#3-安装python依赖项">¶</a>3、安装Python依赖项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --assume-yes python-numpy python-dev python-pip python-wheel</span><br></pre></td></tr></table></figure><h3 id="4-安装gpu依赖项"><a class="header-anchor" href="#4-安装gpu依赖项">¶</a>4、安装GPU依赖项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --assume-yes libcupti-dev</span><br></pre></td></tr></table></figure><h3 id="5-配置安装选项"><a class="header-anchor" href="#5-配置安装选项">¶</a>5、配置安装选项</h3><p>假设目前还在tensorflow目录下，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>即可开始配置参数，常见的配置例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Please specify the location of python. [Default is /usr/bin/python]: /usr/bin/python2.7</span><br><span class="line">Found possible Python library paths:</span><br><span class="line">  /usr/local/lib/python2.7/dist-packages</span><br><span class="line">  /usr/lib/python2.7/dist-packages</span><br><span class="line">Please input the desired Python library path to use.  Default is [/usr/lib/python2.7/dist-packages]</span><br><span class="line"></span><br><span class="line">Using python library path: /usr/local/lib/python2.7/dist-packages</span><br><span class="line">Do you wish to build TensorFlow with MKL support? [y/N]</span><br><span class="line">No MKL support will be enabled for TensorFlow</span><br><span class="line">Please specify optimization flags to use during compilation when bazel option &quot;--config=opt&quot; is specified [Default is -march=native]:</span><br><span class="line">Do you wish to use jemalloc as the malloc implementation? [Y/n]</span><br><span class="line">jemalloc enabled</span><br><span class="line">Do you wish to build TensorFlow with Google Cloud Platform support? [y/N]</span><br><span class="line">No Google Cloud Platform support will be enabled for TensorFlow</span><br><span class="line">Do you wish to build TensorFlow with Hadoop File System support? [y/N]</span><br><span class="line">No Hadoop File System support will be enabled for TensorFlow</span><br><span class="line">Do you wish to build TensorFlow with the XLA just-in-time compiler (experimental)? [y/N]</span><br><span class="line">No XLA support will be enabled for TensorFlow</span><br><span class="line">Do you wish to build TensorFlow with VERBS support? [y/N]</span><br><span class="line">No VERBS support will be enabled for TensorFlow</span><br><span class="line">Do you wish to build TensorFlow with OpenCL support? [y/N]</span><br><span class="line">No OpenCL support will be enabled for TensorFlow</span><br><span class="line">Do you wish to build TensorFlow with CUDA support? [y/N] Y</span><br><span class="line">CUDA support will be enabled for TensorFlow</span><br><span class="line">Do you want to use clang as CUDA compiler? [y/N]</span><br><span class="line">nvcc will be used as CUDA compiler</span><br><span class="line">Please specify the Cuda SDK version you want to use, e.g. 7.0. [Leave empty to default to CUDA 8.0]:</span><br><span class="line">Please specify the location where CUDA 8.0 toolkit is installed. Refer to README.md for more details. [Default is /usr/local/cuda]:</span><br><span class="line">Please specify which gcc should be used by nvcc as the host compiler. [Default is /usr/bin/gcc]:</span><br><span class="line">Please specify the cuDNN version you want to use. [Leave empty to default to cuDNN 6.0]: </span><br><span class="line">Please specify the location where cuDNN 6 library is installed. Refer to README.md for more details. [Default is /usr/local/cuda]:</span><br><span class="line">Please specify a list of comma-separated Cuda compute capabilities you want to build with.</span><br><span class="line">You can find the compute capability of your device at: https://developer.nvidia.com/cuda-gpus.</span><br><span class="line">Please note that each additional compute capability significantly increases your build time and binary size.</span><br><span class="line">[Default is: &quot;3.5,5.2&quot;]:</span><br><span class="line">Do you wish to build TensorFlow with MPI support? [y/N] </span><br><span class="line">MPI support will not be enabled for TensorFlow</span><br><span class="line">Configuration finished</span><br></pre></td></tr></table></figure><p>注意CUDA默认为否，需要用CUDA时，请输入Y。</p><h3 id="6-生成-whl包"><a class="header-anchor" href="#6-生成-whl包">¶</a>6、生成.whl包</h3><ul><li>CPU版本：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel build --config=opt //tensorflow/tools/pip_package:build_pip_package</span><br></pre></td></tr></table></figure><ul><li>GPU版本：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel build --config=opt --config=cuda //tensorflow/tools/pip_package:build_pip_package</span><br></pre></td></tr></table></figure><p>执行如下命令，即可在/tmp/tensorflow_pkg目录下生成<code>.whl</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg</span><br></pre></td></tr></table></figure><h3 id="7-使用pip安装-whl包"><a class="header-anchor" href="#7-使用pip安装-whl包">¶</a>7、使用pip安装.whl包</h3><p>假设安装的是1.0.1版本：（注意：如果版本不一样，如下命令需要修改相应文件名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install /tmp/tensorflow_pkg/tensorflow-1.0.1-cp27-cp27mu-linux_x86_64.whl</span><br></pre></td></tr></table></figure><h3 id="8-验证安装结果"><a class="header-anchor" href="#8-验证安装结果">¶</a>8、验证安装结果</h3><p>TensorFlow已经安装完毕，现在可以测试安装是否成功。<br>首先要注意退出tensorflow的目录，否则会出现<code>ImportError: cannot import name pywrap_tensorflow</code>的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">python</span><br></pre></td></tr></table></figure><p>输入以下Python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">hello = tf.constant(<span class="string">'Hello, TensorFlow!'</span>)</span><br><span class="line">sess = tf.Session()</span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure><p>如果能输出<code>Hello, TensorFlow!</code>，则说明安装成功！</p><h3 id="9-常见问题"><a class="header-anchor" href="#9-常见问题">¶</a>9、常见问题</h3><p>错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: libcudart.so.8.0: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><ul><li><p>临时解决办法：<br>原因是找不到cuda库，需要指定目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=&quot;$LD_LIBRARY_PATH:/usr/local/cuda/lib64&quot;</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></li><li><p>永久解决办法<br>打开~/.bashrc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>在最后一行添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=&quot;$LD_LIBRARY_PATH:/usr/local/cuda/lib64&quot;</span><br></pre></td></tr></table></figure><p>保存后，让其生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>以后每次登陆都会自动执行一次export指令，保证路径永久有效。</p></li></ul><h2 id="pytorch在线安装"><a class="header-anchor" href="#pytorch在线安装">¶</a>PyTorch在线安装</h2><h3 id="1-安装指令获取"><a class="header-anchor" href="#1-安装指令获取">¶</a>1、安装指令获取</h3><p>安装命令可以在<a href="http://pytorch.org/" target="_blank" rel="noopener">官网</a>根据需要选择不同的安装方式</p><h3 id="2-常见问题"><a class="header-anchor" href="#2-常见问题">¶</a>2、常见问题</h3><ul><li><p>如果<code>import torch</code>时报错<br><code>F0822 15:58:51.328765 31898 cudnn.hpp:113] Check failed: status == CUDNN_STATUS_SUCCESS (3 vs. 0) CUDNN_STATUS_BAD_PARAM</code></p><p>安装如下软件可能可以解决问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libtcmalloc-minimal4</span><br></pre></td></tr></table></figure><p>并设置好路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>在.bashrc最后一行添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_PRELOAD=&quot;$LD_PRELOAD:/usr/lib/libtcmalloc_minimal.so.4&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>***/torch/lib/libtorch.so.1: undefined symbol: _ZTIN2at10TensorImplE</code></p><p>可能是和caffe2版本不一致，删除/usr/local/lib下的libcaffe*文件即可</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#概述&quot;&gt;¶&lt;/a&gt;概述&lt;/h2&gt;
&lt;p&gt;本文详细介绍了几种算法库在Linux环境（本文以Ubuntu为例）的安装过程以及常见问题的解决方法，包括OpenCV、Caffe、TensorFlow和PyTorch。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://chason.pro/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="http://chason.pro/tags/Ubuntu/"/>
    
      <category term="OpenCV" scheme="http://chason.pro/tags/OpenCV/"/>
    
      <category term="Caffe" scheme="http://chason.pro/tags/Caffe/"/>
    
      <category term="TensorFlow" scheme="http://chason.pro/tags/TensorFlow/"/>
    
      <category term="PyTorch" scheme="http://chason.pro/tags/PyTorch/"/>
    
      <category term="源码安装" scheme="http://chason.pro/tags/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/"/>
    
      <category term="在线安装" scheme="http://chason.pro/tags/%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>screen教程</title>
    <link href="http://chason.pro/screen-tutorial/"/>
    <id>http://chason.pro/screen-tutorial/</id>
    <published>2017-02-13T16:00:00.000Z</published>
    <updated>2019-05-15T15:36:32.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>假设你现在有一个VPS可以使用，而且系统是Linux，一般都是通过SSH远程登陆进行管理。如果我们需要在VPS上长期运行一个程序，直接在SSH连接中运行程序并不能达成目的，因为程序会在SSH断开时停止运行。而使用<strong>screen</strong>命令就可以避免SSH中断导致的程序中断问题。</p><a id="more"></a><p>首先当然是用Putty或者Xshell登陆VPS，这里就不细说了。</p><h2 id="使用方法"><a class="header-anchor" href="#使用方法">¶</a>使用方法</h2><p>使用<code>screen</code>或者<code>screen -S &lt;your name&gt;</code>命令打开子界面。使用<code>screen</code>时，只能用系统分配的编号来恢复子界面，如果使用<code>screen -S</code>，并附上自定义的名字，就能用名字来恢复子界面，后面会谈如何恢复子界面。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># screen -S my_screen</span></span><br></pre></td></tr></table></figure><p>回车后得到一个新的界面：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>现在就可以在这里运行任何需要长期运行的程序，比如这个简单的Python程序：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim test.py</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">print</span> datetime.datetime.now()</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>程序的效果是每五秒打印一次系统时间：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># python test.py</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">2</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">04.439517</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">2</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">09.444224</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">2</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">14.453887</span></span><br></pre></td></tr></table></figure><p>运行程序后，需要挂起子界面，<strong>按下Ctrl+A后抬起，然后按下d键</strong>，此时就会切换回原来的界面，并提示“detached”：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># screen -S my_screen</span></span><br><span class="line">[detached]</span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>现在即便是退出SSH，也不会影响到screen里面运行的程序，目标已达成。screen不仅仅能保持程序的运行，还能一直保留程序的输出信息，以备查看。</p><p>如果你以后需要查看程序的输出，就要恢复Screen子界面：<code>screen -ls</code>可以输出目前正在运行的子界面列表：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># screen -ls</span></span><br><span class="line">There is a screen on:</span><br><span class="line"><span class="number">1676</span>.my_screen(Detached)</span><br><span class="line"><span class="number">1</span> Socket <span class="keyword">in</span> /var/run/screen/S-root.</span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>这时自定义名称就能用起来：输入<code>screen -r my_screen</code>，或者<code>screen -r 1676</code>同样可以恢复子界面，但当子界面比较多时可能就比较混乱，推荐用自定义的名字。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># python test.py</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">2</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">04.439517</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">2</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">09.444224</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">2</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">14.453887</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">2</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">19.453887</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">2</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">24.458580</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">2</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">29.463413</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">2</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">34.468418</span></span><br></pre></td></tr></table></figure><p>如果信息太多，就<strong>按下Ctrl+A后抬起，然后按下[键</strong>，就能通过键盘上下键滚动查看历史。</p><h2 id="键绑定"><a class="header-anchor" href="#键绑定">¶</a>键绑定</h2><p>什么？快捷键太多记不住？那就<strong>按下Ctrl+A后抬起，然后按下?键</strong>，查看所有的键绑定。</p><h3 id="一般常用键绑定"><a class="header-anchor" href="#一般常用键绑定">¶</a>一般常用键绑定</h3><ul><li><code>C-a ?</code>    显示所有键绑定信息</li><li><code>C-a w</code>    显示所有窗口列表</li><li><code>C-a C-a</code>    切换到之前显示的窗口</li><li><code>C-a c</code>    创建一个新的运行shell的窗口并切换到该窗口</li><li><code>C-a n</code>    切换到下一个窗口</li><li><code>C-a p</code>    切换到前一个窗口(与C-a n相对)</li><li><code>C-a 0..9</code>    切换到窗口0…9</li><li><code>C-a a</code>    发送 C-a到当前窗口</li><li><code>C-a d</code>    暂时断开screen会话</li><li><code>C-a k</code>    杀掉当前窗口</li><li><code>C-a [</code>    进入拷贝/回滚模式</li></ul><h3 id="其他常用命令选项"><a class="header-anchor" href="#其他常用命令选项">¶</a>其他常用命令选项</h3><ul><li><code>-c file</code>    使用配置文件file，而不使用默认的$HOME/.screenrc</li><li><code>-h num</code>    指定历史回滚缓冲区大小为num行</li><li><code>-list|-ls</code>    列出现有screen会话，格式为pid.tty.host</li><li><code>-d -m</code>    启动一个开始就处于断开模式的会话</li><li><code>-r sessionowner</code>    重新连接一个断开的会话。</li><li><code>-S sessionname</code>    创建screen会话时为会话指定一个名字</li><li><code>-v</code>    显示screen版本信息</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;假设你现在有一个VPS可以使用，而且系统是Linux，一般都是通过SSH远程登陆进行管理。如果我们需要在VPS上长期运行一个程序，直接在SSH连接中运行程序并不能达成目的，因为程序会在SSH断开时停止运行。而使用&lt;strong&gt;screen&lt;/strong&gt;命令就可以避免SSH中断导致的程序中断问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://chason.pro/categories/Linux/"/>
    
    
      <category term="SSH" scheme="http://chason.pro/tags/SSH/"/>
    
      <category term="screen" scheme="http://chason.pro/tags/screen/"/>
    
      <category term="VPS" scheme="http://chason.pro/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://chason.pro/hello-world/"/>
    <id>http://chason.pro/hello-world/</id>
    <published>2017-02-10T16:00:00.000Z</published>
    <updated>2017-05-10T16:49:43.494Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start"><a class="header-anchor" href="#quick-start">¶</a>Quick Start</h2><h3 id="create-a-new-post"><a class="header-anchor" href="#create-a-new-post">¶</a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="run-server"><a class="header-anchor" href="#run-server">¶</a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files"><a class="header-anchor" href="#generate-static-files">¶</a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="header-anchor" href="#deploy-to-remote-sites">¶</a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;quick-start&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#quick-start&quot;&gt;¶&lt;/a&gt;Quick Start&lt;/h2&gt;
&lt;h3 id=&quot;create-a-new-post&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#create-a-new-post&quot;&gt;¶&lt;/a&gt;Create a new post&lt;/h3&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
